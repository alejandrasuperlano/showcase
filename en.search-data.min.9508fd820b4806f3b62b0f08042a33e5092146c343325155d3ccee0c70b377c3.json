[{"id":0,"href":"/showcase/docs/shortcodes/workshop-1/","title":"Workshop 1","section":"Shortcodes","content":" Illusion 1: Stepping Feet # Click on the canvas to reveal the illusion. Illusion 2 # Image kernel # Un kernel o mascara es una matriz usada para aplicar algun tipo de efecto como difuminado, detección de bordes , sobre una imagen. Eso se logra realizando una convolución entre el kernel y la imagen. ¿Qué es una convolución?\nEn procesamiento de imagenes, una convolución consiste en multiplicar cada píxel de la imagen por la entrada correspondiente del kernel, luego al sumar todos los resultados, se obtiene el valor del nuevo píxel. A modo de ejemplo, se escogieron los siguientes kernels para mostrar su aplicación:\nSharpening \\[\\begin{bmatrix} 0 \u0026amp; -1 \u0026amp; 0\\\\ -1 \u0026amp; 5 \u0026amp; -1\\\\ 0 \u0026amp; -1 \u0026amp; 0\\\\ \\end{bmatrix}\\] Emboss \\[\\begin{bmatrix} -2 \u0026amp; -1 \u0026amp; 0\\\\ -1 \u0026amp; 1 \u0026amp; 1\\\\ 0 \u0026amp; 1 \u0026amp; 2\\\\ \\end{bmatrix}\\] Blur \\[\\begin{bmatrix} 0.0625 \u0026amp; 0.125 \u0026amp; 0.0625\\\\ 0.125 \u0026amp; 0.25 \u0026amp; 0.125\\\\ 0.0625 \u0026amp; 0.125 \u0026amp; 0.0625\\\\ \\end{bmatrix}\\] A continuación se muestra la función principal, la cual es la encargada de calcula el nuevo valor de cada píxel:\nlet applyKernelToPixel = (x, y, kernel, kernelSize) =\u0026gt; { let newR = 0.0; let newG = 0.0; let newB = 0.0; // Go through each kernel entry for (let r = 0; r \u0026lt; kernelSize; r++) { for (let c = 0; c \u0026lt; kernelSize; c++) { // Compute the offset let rowOffset = 1 - r; let colOffset = 1 - c; let imageRow = x - rowOffset; let imageCol = y - colOffset; let currentPixel = originalImg.get(imageRow, imageCol); // Compute new value for each channel newR += p.red(currentPixel) * kernel[r][c]; newG += p.green(currentPixel) * kernel[r][c]; newB += p.blue(currentPixel) * kernel[r][c]; } } // In case the new value is greater than 255 newR = p.constrain(newR, 0, 255); newG = p.constrain(newG, 0, 255); newB = p.constrain(newB, 0, 255); return p.color(newR, newG, newB); }; Image histogram # Un histograma de una imagen consiste en la representación gráfica de la distribución tonal de la imagen, trazando el número de píxeles de cada canal.\nEn el eje horizontal representa las variaciones tonales, mientras que el vertical, representa la cantidad de píxeles en un tono particular.\n¿Cómo interpretar un histograma?\nEl lado izquierdo del eje horizontal representa las áreas oscuras y el derecho representa las áreas iluminadas.\nPor ejemplo, para una imagen oscura, esta tendrá la mayoría de puntos dibujados en el lado izquiero del histograma. A continuación se muestra la función principal, la cual es la encargada de contar la cantidad de píxeles en cada valor de un determinado canal:\nlet countPixels = () =\u0026gt; { // Go through each pixel for (let x = 0; x \u0026lt; img.width; x++) { for (let y = 0; y \u0026lt; img.height; y++) { let pixel = img.get(x, y); // Add 1 to the current tonal value let value = currentColor === \u0026#34;red\u0026#34; ? p.red(pixel) : currentColor === \u0026#34;green\u0026#34; ? p.green(pixel) : p.blue(pixel); pixels[value] += 1; } } }; Lightness tools # La luminosidad es la percepción visual de la luminancia de un objeto. En colorimetría, es una predicción de que tan iluminado aparecerá un color para un determinado observador. ¿Qué es la luminancia? Es la médida de intensidad lumínica por unidad de área de la luz viajando en una determinada dirección. Es decir, describe la cantidad de luz que pasa a través, es emitida o reflejada de un área particular.\nExisten varias formas de calcular la luminosidad de un color. A modo de ejemplo, se mostrarán las siguientes 4: Media aritmética \\[I=\\frac{R\u0026#43;G\u0026#43;B}{3}\\] HSV \\[V=max(R,G,B)\\] HSL \\[L=\\frac{max(R,G,B)\u0026#43;min(R,G,B)}{2}\\] Luma \\[Y=0.2126\\cdot R\u0026#43; 0.7152\\cdot G\u0026#43;0.0722\\cdot B\\] A continuación, se muestra la implementación de las 4 maneras de calcular la luminosidad expuestas anteriormente, junto con la función encargada de aplicar ese cálculo a cada pixel de la imagen:\nlet lightnessModes = { mean: (color) =\u0026gt; { return (p.red(color) + p.green(color) + p.blue(color)) / 3; }, hsv: (color) =\u0026gt; { return Math.max((p.red(color), p.green(color), p.blue(color))); }, hsl: (color) =\u0026gt; { let max = Math.max((p.red(color), p.green(color), p.blue(color))); let min = Math.min((p.red(color), p.green(color), p.blue(color))); return (max + min) / 2; }, luma: (color) =\u0026gt; { return ( 0.2126 * p.red(color) + 0.7152 * p.green(color) + 0.0722 * p.blue(color) ); }, }; let applyLightness = (mode) =\u0026gt; { // Extract the current function let lightness = lightnessModes[mode]; // Go through each pixel for (let i = 0; i \u0026lt; originalImg.width; i++) { for (let j = 0; j \u0026lt; originalImg.height; j++) { let newPixel = lightness(originalImg.get(i, j)); currentImg.set(i, j, p.color(newPixel)); } } }; "}]