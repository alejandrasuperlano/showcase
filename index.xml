<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introduction on Visual computing</title><link>https://mbolanoss.github.io/showcase/</link><description>Recent content in Introduction on Visual computing</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://mbolanoss.github.io/showcase/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://mbolanoss.github.io/showcase/docs/Taller-1/1-Visual-Illusions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://mbolanoss.github.io/showcase/docs/Taller-1/1-Visual-Illusions/</guid><description>Visual Illusions ğŸ‘ # Workshop Estudie, implemente y discuta posibles aplicaciones de algunos fenÃ³menos visuales e ilusiones Ã³pticas conocidas.
Illusion 1: Stepping Feet ğŸ‘£ # Marco Teorico # La ilusiÃ³n &amp;ldquo;Stepping Feet&amp;rdquo; es un fenÃ³meno de percepciÃ³n del movimiento, donde se percibe que el recuadro azul y amarillo varÃ­an sus velocidades relativa de manera dramÃ¡tica, aunque en realidad su movimiento es constante.
Â¿QuÃ© estÃ¡ pasando? Cuando el recuadro azul se encuentra sobre las lÃ­neas blancas, el contraste es alto, por lo cual el movimiento se percibe mÃ¡s rÃ¡pido que su velocidad real.</description></item><item><title/><link>https://mbolanoss.github.io/showcase/docs/Taller-1/2-Visual-Masking/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://mbolanoss.github.io/showcase/docs/Taller-1/2-Visual-Masking/</guid><description>Visual Masking ğŸ’¡ # Workshop Implementar una aplicaciÃ³n web de procesamiento de imagenes que soporte varios kernels y ademÃ¡s:
VisualizaciÃ³n de histograma de la imagen Diferentes herramientes de luminosidad Marco teÃ³rico # Kernel # Un kernel o mascara es una matriz usada para aplicar algun tipo de efecto como difuminado, detecciÃ³n de bordes , sobre una imagen. Eso se logra realizando una convoluciÃ³n entre el kernel y la imagen. Â¿QuÃ© es una convoluciÃ³n?</description></item><item><title/><link>https://mbolanoss.github.io/showcase/docs/Taller-2/1-WebGL-3D-App/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://mbolanoss.github.io/showcase/docs/Taller-2/1-WebGL-3D-App/</guid><description>3D APP : 3D Audio Visualizer ğŸ¶ # Workshop Implement a 3d webgl application. The p5.treegl or any other libraries may be used
Marco teÃ³rico # SeÃ±ales electromagnÃ©ticas # Como componente teÃ³rico principal de la aplicaciÃ³n, se tienen las seÃ±ales de electromagnÃ©ticas, las cuales, a manera de resumen, se pueden descomponer en varias ondas sinusoidales periÃ³dicas, y cada una tiene una serie de caracterÃ­sticas propias de una onda electromagnÃ©tica. En particular, nos interesan 2 de estas:</description></item><item><title/><link>https://mbolanoss.github.io/showcase/docs/Taller-3/1-Color-Blending/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://mbolanoss.github.io/showcase/docs/Taller-3/1-Color-Blending/</guid><description>Color Blending ğŸ”´ğŸŸ ğŸŸ¡ # Exercises Averiguar el cÃ³digo js de los sketches de ejemplo. Implementar otros modos de blending. Tomar esta referencia como un punto de partida. Marco teÃ³rico # Color Mixing # Existen 3 tipos de mezcla de colores: aditivo, sustractivo y promedio.
Aditivo Por convenciÃ³n, los 3 colores primarios son el rojo, el verde y el azul. La ausencia de luz de cualquier color corresponde con negro. Si se mezclan los 3 colores en mismas propociones, el resultado es neutral (blanco o gris).</description></item><item><title/><link>https://mbolanoss.github.io/showcase/docs/Taller-3/2-Texturing-UV-Visualization-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://mbolanoss.github.io/showcase/docs/Taller-3/2-Texturing-UV-Visualization-1/</guid><description>UV Visualization - Exercise 1 ğŸ”´ğŸŸ¢ğŸ”µ # Exercise Redefinir las coordenas de textura de la figura, para invertir la imagen de abajo.
SoluciÃ³n #1 # JavaScript: Ajustando coordenadas u &amp;amp; v en vertex # ConstrucciÃ³n de la figura invirtiendo las coordenadas de la textura en el llamado a vertex.
La funciÃ³n vertex tiene la siguiente estructura:
vertex(x, y, [z], [u], [v]) Siendo los parametros los siguientes:
x - x-coordinate of the vertex y - y-coordinate of the vertex z - z-coordinate of the vertex u - the vertex&amp;rsquo;s texture u-coordinate v - the vertex&amp;rsquo;s texture v-coordinate Source Code: JavaScript // ConstrucciÃ³n de la figura invirtiendo las coordenadas de la textura // en el llamado a vertex let uvShader; function preload() { // No se pasa ninguna matriz al shader uvShader = readShader(&amp;#39;/showcase/sketches/uv_1/uv.</description></item><item><title/><link>https://mbolanoss.github.io/showcase/docs/Taller-3/3-Texturing-UV-Visualization-2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://mbolanoss.github.io/showcase/docs/Taller-3/3-Texturing-UV-Visualization-2/</guid><description>UV Visualization - Exercise 2 ğŸŸ¥ğŸŸ©ğŸŸ¦ # Exercises Incluir el canal azul dentro de la visualizaciÃ³n uv. Utilizar otras figuras, diferentes a quad, como filtros. Source Code # Source Code: JavaScript let easycam; let uvShader; let opacity; let mode; let figure = &amp;#39;Ellipse ğŸŒŒ&amp;#39;; const combinationMapper = {&amp;#39;Blue ğŸ”µ + Green ğŸŸ¢&amp;#39; : 0, &amp;#39;Blue ğŸ”µ + Red ğŸ”´&amp;#39; : 1, &amp;#39;Green ğŸŸ¢ + Red ğŸ”´&amp;#39; : 2, &amp;#39;Green ğŸŸ¢ + Blue ğŸ”µ&amp;#39; : 3, &amp;#39;Red ğŸ”´ + Blue ğŸ”µ&amp;#39; : 4, &amp;#39;Red ğŸ”´ + Green ğŸŸ¢&amp;#39; : 5 }; function preload() { // Define geometry in world space (i.</description></item><item><title/><link>https://mbolanoss.github.io/showcase/docs/Taller-3/4-Color-Brightness-and-Tinting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://mbolanoss.github.io/showcase/docs/Taller-3/4-Color-Brightness-and-Tinting/</guid><description>Color Brightness ğŸŒŸ and Tinting ğŸ‘©â€ğŸ¨ # Exercises Implementar otras modos de luminosidad, como HSV, HSL y promedio. Implementar tintado de texturas para mezclar colores y texels. Marco teÃ³rico # Herramientas de luminosidad # La luminosidad es la percepciÃ³n visual de la luminancia de un objeto. En colorimetrÃ­a, es una predicciÃ³n de que tan iluminado aparecerÃ¡ un color para un determinado observador. Â¿QuÃ© es la luminancia? Es la mÃ©dida de intensidad lumÃ­nica por unidad de Ã¡rea de la luz viajando en una determinada direcciÃ³n.</description></item><item><title/><link>https://mbolanoss.github.io/showcase/docs/Taller-3/5-Image-Processing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://mbolanoss.github.io/showcase/docs/Taller-3/5-Image-Processing/</guid><description>Image/Video processing ğŸ–¼ï¸ # Workshop Implement an image / video processing app supporting different masks, including other kernel sizes different than 3x3, and:
A region-of-interest base tool to selectively apply a given mask.Hint: circular regions around the mouse pointer are handy and quite simple to implement by means of glsl distance. A magnifier tool. Requires a bit of research. For instance, look for it in shadertoy. Integrate luma and other coloring brightness tools.</description></item><item><title/><link>https://mbolanoss.github.io/showcase/docs/Taller-3/6-Lighting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://mbolanoss.github.io/showcase/docs/Taller-3/6-Lighting/</guid><description>Lighting ğŸ”¦ # Workshop Implement a scene having the following lighting equation:
\[a = ambient\cdot ambient4\] where ambient4 is the ambient light color.
Marco teÃ³rico # La iluminaciÃ³n local estÃ¡ dada por la siguiente ecuaciÃ³n: En este caso los terminos d y s de la ecuaciÃ³n no nos interesan ya que solo vamos a modificar la luz ambiental.
De modo que la ecuaciÃ³n a usar es la siguiente:
\[\lambda = a\cdot \rho\] SoluciÃ³n y resultados # Fragment shader precision mediump float; uniform vec4 uMaterialColor; uniform vec4 lightColor; uniform float ambient; void main() { vec4 ambient4 = lightColor * ambient; gl_FragColor = ambient4 * uMaterialColor; } Aplicaciones # En los grÃ¡ficos por ordenador en 3D, el trazado de rayos es una tÃ©cnica de modelado del transporte de la luz para su uso en una amplia variedad de algoritmos de renderizado para generar imÃ¡genes digitales.</description></item><item><title/><link>https://mbolanoss.github.io/showcase/docs/Taller-3/7-Procedural-texturing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://mbolanoss.github.io/showcase/docs/Taller-3/7-Procedural-texturing/</guid><description> Procedural texturing âš½ # Exercise Adapte otros patrones del libro de shaders y apliquelos a otras figuras 3D.
SoluciÃ³n y Resultados # Conclusiones # Existe una gran cantidad de recursos online que proveen fragment shaders completos. Asimismo, existe varios recursos de aprendizaje acerca de este tema. Referencias # Patricio Gonzales Vivo &amp;amp; Jen Lowe (2022, 27 noviembre). The Book of Shaders. https://thebookofshaders.com/09/</description></item></channel></rss>