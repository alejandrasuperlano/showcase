<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introduction on Visual computing</title><link>https://mbolanoss.github.io/showcase/</link><description>Recent content in Introduction on Visual computing</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://mbolanoss.github.io/showcase/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://mbolanoss.github.io/showcase/docs/Taller-1/1-Visual-Illusions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://mbolanoss.github.io/showcase/docs/Taller-1/1-Visual-Illusions/</guid><description>Visual Illusions üëÅ # Workshop Estudie, implemente y discuta posibles aplicaciones de algunos fen√≥menos visuales e ilusiones √≥pticas conocidas.
Illusion 1: Stepping Feet üë£ # Marco Teorico # La ilusi√≥n &amp;ldquo;Stepping Feet&amp;rdquo; es un fen√≥meno de percepci√≥n del movimiento, donde se percibe que el recuadro azul y amarillo var√≠an sus velocidades relativa de manera dram√°tica, aunque en realidad su movimiento es constante.
¬øQu√© est√° pasando? Cuando el recuadro azul se encuentra sobre las l√≠neas blancas, el contraste es alto, por lo cual el movimiento se percibe m√°s r√°pido que su velocidad real.</description></item><item><title/><link>https://mbolanoss.github.io/showcase/docs/Taller-1/2-Visual-Masking/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://mbolanoss.github.io/showcase/docs/Taller-1/2-Visual-Masking/</guid><description>Visual Masking üí° # Workshop Implementar una aplicaci√≥n web de procesamiento de imagenes que soporte varios kernels y adem√°s:
Visualizaci√≥n de histograma de la imagen Diferentes herramientes de luminosidad Marco te√≥rico # Kernel # Un kernel o mascara es una matriz usada para aplicar algun tipo de efecto como difuminado, detecci√≥n de bordes , sobre una imagen. Eso se logra realizando una convoluci√≥n entre el kernel y la imagen. ¬øQu√© es una convoluci√≥n?</description></item><item><title/><link>https://mbolanoss.github.io/showcase/docs/Taller-2/1-WebGL-3D-App/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://mbolanoss.github.io/showcase/docs/Taller-2/1-WebGL-3D-App/</guid><description>3D APP : 3D Audio Visualizer üé∂ # Workshop Implement a 3d webgl application. The p5.treegl or any other libraries may be used
Marco te√≥rico # Se√±ales electromagn√©ticas # Como componente te√≥rico principal de la aplicaci√≥n, se tienen las se√±ales de electromagn√©ticas, las cuales, a manera de resumen, se pueden descomponer en varias ondas sinusoidales peri√≥dicas, y cada una tiene una serie de caracter√≠sticas propias de una onda electromagn√©tica. En particular, nos interesan 2 de estas:</description></item><item><title/><link>https://mbolanoss.github.io/showcase/docs/Taller-3/1-Color-Blending/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://mbolanoss.github.io/showcase/docs/Taller-3/1-Color-Blending/</guid><description>Color Blending üî¥üü†üü° # Exercises Averiguar el c√≥digo js de los sketches de ejemplo. Implementar otros modos de blending. Tomar esta referencia como un punto de partida. Marco te√≥rico # Color Mixing # Existen 3 tipos de mezcla de colores: aditivo, sustractivo y promedio.
Aditivo Por convenci√≥n, los 3 colores primarios son el rojo, el verde y el azul. La ausencia de luz de cualquier color corresponde con negro. Si se mezclan los 3 colores en mismas propociones, el resultado es neutral (blanco o gris).</description></item><item><title/><link>https://mbolanoss.github.io/showcase/docs/Taller-3/2-Texturing-UV-Visualization-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://mbolanoss.github.io/showcase/docs/Taller-3/2-Texturing-UV-Visualization-1/</guid><description>UV Visualization - Exercise 1 üî¥üü¢üîµ # Exercise Redefinir las coordenas de textura de la figura, para invertir la imagen de abajo.
Soluci√≥n #1 # JavaScript: Ajustando coordenadas u &amp;amp; v en vertex # Construcci√≥n de la figura invirtiendo las coordenadas de la textura en el llamado a vertex.
La funci√≥n vertex tiene la siguiente estructura:
vertex(x, y, [z], [u], [v]) Siendo los parametros los siguientes:
x - x-coordinate of the vertex y - y-coordinate of the vertex z - z-coordinate of the vertex u - the vertex&amp;rsquo;s texture u-coordinate v - the vertex&amp;rsquo;s texture v-coordinate Source Code: JavaScript // Construcci√≥n de la figura invirtiendo las coordenadas de la textura // en el llamado a vertex let uvShader; function preload() { // No se pasa ninguna matriz al shader uvShader = readShader(&amp;#39;/showcase/sketches/uv_1/uv.</description></item><item><title/><link>https://mbolanoss.github.io/showcase/docs/Taller-3/3-Texturing-UV-Visualization-2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://mbolanoss.github.io/showcase/docs/Taller-3/3-Texturing-UV-Visualization-2/</guid><description>UV Visualization - Exercise 2 üü•üü©üü¶ # Exercises Incluir el canal azul dentro de la visualizaci√≥n uv. Utilizar otras figuras, diferentes a quad, como filtros. Soluci√≥n y Resultados # Utilice el primer selector para cambiar los canales visualizados. Utilice el segundo selector para cambiar la forma del filtro. Aplicaciones # Cuando se utiliza el t√©rmino &amp;ldquo;shader&amp;rdquo; sobre un videojuego, se trata de un programa utilizado para renderizar diferentes p√≠xeles. Los shaders en los juegos se utilizan cuando se detallan las sombras, la iluminaci√≥n, los gradientes de las texturas y mucho m√°s.</description></item><item><title/><link>https://mbolanoss.github.io/showcase/docs/Taller-3/4-Color-Brightness-and-Tinting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://mbolanoss.github.io/showcase/docs/Taller-3/4-Color-Brightness-and-Tinting/</guid><description>Color Brightness üåü and Tinting üë©‚Äçüé® # Exercises Implementar otras modos de luminosidad, como HSV, HSL y promedio. Implementar tintado de texturas para mezclar colores y texels. Marco te√≥rico # Herramientas de luminosidad # La luminosidad es la percepci√≥n visual de la luminancia de un objeto. En colorimetr√≠a, es una predicci√≥n de que tan iluminado aparecer√° un color para un determinado observador. ¬øQu√© es la luminancia? Es la m√©dida de intensidad lum√≠nica por unidad de √°rea de la luz viajando en una determinada direcci√≥n.</description></item><item><title/><link>https://mbolanoss.github.io/showcase/docs/Taller-3/5-Image-Processing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://mbolanoss.github.io/showcase/docs/Taller-3/5-Image-Processing/</guid><description>Image/Video processing üñºÔ∏è # Workshop Implement an image / video processing app supporting different masks, including other kernel sizes different than 3x3, and:
A region-of-interest base tool to selectively apply a given mask.Hint: circular regions around the mouse pointer are handy and quite simple to implement by means of glsl distance. A magnifier tool. Requires a bit of research. For instance, look for it in shadertoy. Integrate luma and other coloring brightness tools.</description></item><item><title/><link>https://mbolanoss.github.io/showcase/docs/Taller-3/6-Lighting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://mbolanoss.github.io/showcase/docs/Taller-3/6-Lighting/</guid><description>Lighting üî¶ # Workshop Implement a scene having the following lighting equation:
\[a = ambient\cdot ambient4\] where ambient4 is the ambient light color.
Marco te√≥rico # La iluminaci√≥n local est√° dada por la siguiente ecuaci√≥n: En este caso los terminos d y s de la ecuaci√≥n no nos interesan ya que solo vamos a modificar la luz ambiental.
De modo que la ecuaci√≥n a usar es la siguiente:
\[\lambda = a\cdot \rho\] Soluci√≥n y resultados # Fragment shader precision mediump float; uniform vec4 uMaterialColor; uniform vec4 lightColor; uniform float ambient; void main() { vec4 ambient4 = lightColor * ambient; gl_FragColor = ambient4 * uMaterialColor; } Conclusiones # Vemos como el color de la luz ambiental produce un efecto de tinting sobre las figuras renderizadas.</description></item></channel></rss>