<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Introduction on Visual computing</title><link>https://mbolanoss.github.io/showcase/</link><description>Recent content in Introduction on Visual computing</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://mbolanoss.github.io/showcase/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://mbolanoss.github.io/showcase/docs/Taller-1/1-Visual-Illusions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://mbolanoss.github.io/showcase/docs/Taller-1/1-Visual-Illusions/</guid><description>Visual Illusions 👁 # Workshop Estudie, implemente y discuta posibles aplicaciones de algunos fenómenos visuales e ilusiones ópticas conocidas.
Illusion 1: Stepping Feet 👣 # Marco Teorico # La ilusión &amp;ldquo;Stepping Feet&amp;rdquo; es un fenómeno de percepción del movimiento, donde se percibe que el recuadro azul y amarillo varían sus velocidades relativa de manera dramática, aunque en realidad su movimiento es constante.
¿Qué está pasando? Cuando el recuadro azul se encuentra sobre las líneas blancas, el contraste es alto, por lo cual el movimiento se percibe más rápido que su velocidad real.</description></item><item><title/><link>https://mbolanoss.github.io/showcase/docs/Taller-1/2-Visual-Masking/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://mbolanoss.github.io/showcase/docs/Taller-1/2-Visual-Masking/</guid><description>Visual Masking 💡 # Workshop Implementar una aplicación web de procesamiento de imagenes que soporte varios kernels y además:
Visualización de histograma de la imagen Diferentes herramientes de luminosidad Marco teórico # Kernel # Un kernel o mascara es una matriz usada para aplicar algun tipo de efecto como difuminado, detección de bordes , sobre una imagen. Eso se logra realizando una convolución entre el kernel y la imagen. ¿Qué es una convolución?</description></item><item><title/><link>https://mbolanoss.github.io/showcase/docs/Taller-2/1-WebGL-3D-App/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://mbolanoss.github.io/showcase/docs/Taller-2/1-WebGL-3D-App/</guid><description>3D APP : 3D Audio Visualizer 🎶 # Workshop Implement a 3d webgl application. The p5.treegl or any other libraries may be used
Marco teórico # Señales electromagnéticas # Como componente teórico principal de la aplicación, se tienen las señales de electromagnéticas, las cuales, a manera de resumen, se pueden descomponer en varias ondas sinusoidales periódicas, y cada una tiene una serie de características propias de una onda electromagnética. En particular, nos interesan 2 de estas:</description></item><item><title/><link>https://mbolanoss.github.io/showcase/docs/Taller-3/1-Color-Blending/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://mbolanoss.github.io/showcase/docs/Taller-3/1-Color-Blending/</guid><description>Color Blending 🔴🟠🟡 # Exercises Averiguar el código js de los sketches de ejemplo. Implementar otros modos de blending. Tomar esta referencia como un punto de partida. Marco teórico # Color Mixing # Existen 3 tipos de mezcla de colores: aditivo, sustractivo y promedio.
Aditivo Por convención, los 3 colores primarios son el rojo, el verde y el azul. La ausencia de luz de cualquier color corresponde con negro. Si se mezclan los 3 colores en mismas propociones, el resultado es neutral (blanco o gris).</description></item><item><title/><link>https://mbolanoss.github.io/showcase/docs/Taller-3/2-Texturing-UV-Visualization-1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://mbolanoss.github.io/showcase/docs/Taller-3/2-Texturing-UV-Visualization-1/</guid><description>UV Visualization - Exercise 1 🔴🟢🔵 # Exercise Redefinir las coordenas de textura de la figura, para invertir la imagen de abajo.
Solución #1 # JavaScript: Ajustando coordenadas u &amp;amp; v en vertex # Construcción de la figura invirtiendo las coordenadas de la textura en el llamado a vertex.
La función vertex tiene la siguiente estructura:
vertex(x, y, [z], [u], [v]) Siendo los parametros los siguientes:
x - x-coordinate of the vertex y - y-coordinate of the vertex z - z-coordinate of the vertex u - the vertex&amp;rsquo;s texture u-coordinate v - the vertex&amp;rsquo;s texture v-coordinate Source Code: JavaScript // Construcción de la figura invirtiendo las coordenadas de la textura // en el llamado a vertex let uvShader; function preload() { // No se pasa ninguna matriz al shader uvShader = readShader(&amp;#39;/showcase/sketches/uv_1/uv.</description></item><item><title/><link>https://mbolanoss.github.io/showcase/docs/Taller-3/3-Texturing-UV-Visualization-2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://mbolanoss.github.io/showcase/docs/Taller-3/3-Texturing-UV-Visualization-2/</guid><description>UV Visualization - Exercise 2 🟥🟩🟦 # Exercises Incluir el canal azul dentro de la visualización uv. Utilizar otras figuras, diferentes a quad, como filtros. Source Code # Source Code: JavaScript let easycam; let uvShader; let opacity; let mode; let figure = &amp;#39;Ellipse 🌌&amp;#39;; const combinationMapper = {&amp;#39;Blue 🔵 + Green 🟢&amp;#39; : 0, &amp;#39;Blue 🔵 + Red 🔴&amp;#39; : 1, &amp;#39;Green 🟢 + Red 🔴&amp;#39; : 2, &amp;#39;Green 🟢 + Blue 🔵&amp;#39; : 3, &amp;#39;Red 🔴 + Blue 🔵&amp;#39; : 4, &amp;#39;Red 🔴 + Green 🟢&amp;#39; : 5 }; function preload() { // Define geometry in world space (i.</description></item><item><title/><link>https://mbolanoss.github.io/showcase/docs/Taller-3/4-Color-Brightness-and-Tinting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://mbolanoss.github.io/showcase/docs/Taller-3/4-Color-Brightness-and-Tinting/</guid><description>Color Brightness 🌟 and Tinting 👩‍🎨 # Exercises Implementar otras modos de luminosidad, como HSV, HSL y promedio. Implementar tintado de texturas para mezclar colores y texels. Marco teórico # Herramientas de luminosidad # La luminosidad es la percepción visual de la luminancia de un objeto. En colorimetría, es una predicción de que tan iluminado aparecerá un color para un determinado observador. ¿Qué es la luminancia? Es la médida de intensidad lumínica por unidad de área de la luz viajando en una determinada dirección.</description></item><item><title/><link>https://mbolanoss.github.io/showcase/docs/Taller-3/5-Image-Processing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://mbolanoss.github.io/showcase/docs/Taller-3/5-Image-Processing/</guid><description>Image/Video processing 🖼️ # Workshop Implement an image / video processing app supporting different masks, including other kernel sizes different than 3x3, and:
A region-of-interest base tool to selectively apply a given mask.Hint: circular regions around the mouse pointer are handy and quite simple to implement by means of glsl distance. A magnifier tool. Requires a bit of research. For instance, look for it in shadertoy. Integrate luma and other coloring brightness tools.</description></item><item><title/><link>https://mbolanoss.github.io/showcase/docs/Taller-3/6-Lighting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://mbolanoss.github.io/showcase/docs/Taller-3/6-Lighting/</guid><description>Lighting 🔦 # Workshop Implement a scene having the following lighting equation:
\[a = ambient\cdot ambient4\] where ambient4 is the ambient light color.
Marco teórico # La iluminación local está dada por la siguiente ecuación: En este caso los terminos d y s de la ecuación no nos interesan ya que solo vamos a modificar la luz ambiental.
De modo que la ecuación a usar es la siguiente:
\[\lambda = a\cdot \rho\] Solución y resultados # Fragment shader precision mediump float; uniform vec4 uMaterialColor; uniform vec4 lightColor; uniform float ambient; void main() { vec4 ambient4 = lightColor * ambient; gl_FragColor = ambient4 * uMaterialColor; } Aplicaciones # En los gráficos por ordenador en 3D, el trazado de rayos es una técnica de modelado del transporte de la luz para su uso en una amplia variedad de algoritmos de renderizado para generar imágenes digitales.</description></item><item><title/><link>https://mbolanoss.github.io/showcase/docs/Taller-3/7-Procedural-texturing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://mbolanoss.github.io/showcase/docs/Taller-3/7-Procedural-texturing/</guid><description> Procedural texturing ⚽ # Exercise Adapte otros patrones del libro de shaders y apliquelos a otras figuras 3D.
Solución y Resultados # Conclusiones # Existe una gran cantidad de recursos online que proveen fragment shaders completos. Asimismo, existe varios recursos de aprendizaje acerca de este tema. Referencias # Patricio Gonzales Vivo &amp;amp; Jen Lowe (2022, 27 noviembre). The Book of Shaders. https://thebookofshaders.com/09/</description></item></channel></rss>