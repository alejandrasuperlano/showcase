[{"id":0,"href":"/showcase/docs/shortcodes/Visual-Illusions/","title":"Visual Illusions","section":"Shortcodes","content":" Visual Illusions # Workshop Estudie, implemente y discuta posibles aplicaciones de algunos fenómenos visuales e ilusiones ópticas conocidas.\nIllusion 1: Stepping Feet # Marco Teorico # La ilusión \u0026ldquo;Stepping Feet\u0026rdquo; es un fenómeno de percepción del movimiento, donde se percibe que el recuadro azul y amarillo varían sus velocidades relativa de manera dramática, aunque en realidad su movimiento es constante.\n¿Qué está pasando? Cuando el recuadro azul se encuentra sobre las líneas blancas, el contraste es alto, por lo cual el movimiento se percibe más rápido que su velocidad real. Por otro lado, cuando el recuadro se encuentra sobre las líneas negras, el contraste resultante es bajo y más difícil de ver.\nEl efecto contrario ocurre para el recuadro amarillo, resultando en la ilusión de que los recuadros dan pasos alternadamente.\nDebido a lo anterior, cuando el contraste desaparece, es posible ver que los recuadros se mueven a la misma velocidad.\nSolucion y resultados # Este efecto es más pronunciado cuando se fija la visión en la zona entre los recuadros. Haz click en el canvas para revelar la ilusión. Source Code # let x = 0; // Posición en x de los recuadros let vx = 0.5; // Velocidad de desplazamiento let w = 50; // Ancho de los recuadros function setup() { createCanvas(400, 250); colorMode(RGB, 255); } function draw() { // De acuerdo al mouseIsPressed se pinta un fondo con alto o bajo contraste if (mouseIsPressed) { lowContrastBackground(); } else { highContrastBackground(); } // Actualización de la velocidad cuando llega al limite del canvas if (x + vx \u0026gt; width - w || x + vx \u0026lt; 0) { vx *= -1; } // Actualización de la posición en cada iteración x += vx; noStroke(); // Recuadro amarillo fill(color(244, 244, 0)); rect(x, 80, w, 20); // Recuadro azul fill(color(4, 4, 156)); rect(x, 160, w, 20); } function highContrastBackground() { for (let i = 0; i \u0026lt; 750; i += 9) { if (i % 2 == 0) { fill(242, 242, 242, 255); } else { fill(12, 12, 12, 255); } rect(i, 0, 9, 400); } } function lowContrastBackground() { for (let i = 0; i \u0026lt; 750; i += 9) { if (i % 2 == 0) { fill(140); } else { fill(116); } rect(i, 0, 9, 400); } } Illusion 2 : Stereokinetic Effect (SKE) # Marco Teorico # La rotación de las figuras adecuadas puede crear una ilusión tridimensional. Un ejemplo que permite demostarlo es el efecto estereocinético el cual una ilusión de profundidad. Puede pasar algún tiempo hasta que surja la percepción.\n¿Qué es el efecto estereocinético?\nEl efecto estereocinético (SKE) se ha definido y estudiado mediante patrones circulares anidados que giran en una plataforma giratoria. Los círculos deben parecer que no giran, lo que a su vez da lugar a que parecen trasladarse unos a otros. Solucion y resultados # A continuación, podemos observar un ejemplo de lo mencionado anteriormente: Manten el click en el canvas para ver otro tipo de efecto !. Se ha comprobado que las visualizaciones consistentes en simples traslaciones evocan impresiones de profundidad sólidas.\nMusatti (1924) publicó el primer informe sobre los fenómenos estereocinéticos y atribuyó su descubrimiento y denominación a su maestro profesor, Vittorio Benussi Como se observa en la ilusión, un conjunto de anillos concéntricos gira como si estuviera en una plataforma giratoria. Un conjunto más pequeño de anillos en el centro gira alrededor de un eje diferente, lo que puede dar la ilusión de que estos anillos más pequeños tienen profundidad espacial.\nImagen 1 : Efecto estereocinético (SKE) tradicional girada 90°.\nSource Code # A continuación se muestran las funciónes principales las cuales permitieron crear esta ilusion:\nclass Circle { constructor(r, coordR, color) { this.r = r; this.coordR = coordR; this.color = color; } render(centerX, centerY, angle) { const coord = polarCoordinates(this.coordR, angle); const x = coord.x; const y = coord.y; noStroke(); fill(this.color); circle(centerX + x, centerY + y, this.r); } } function polarCoordinates(r, angle) { let x = 0; y = 0; x = r * cos(angle); y = r * sin(angle); return { x, y }; } function renderingCirles() { for (let i = 0; i \u0026lt; circles.length; i++) { circles[i].render(centerX, centerY, angle); } } Aplicaciones # Los candidatos más lógicos son los sistemas que requieren movimiento en tiempo real pero en los que las limitaciones de coste, tamaño o fiabilidad impiden el uso de motores de geometría 3D.\nMapas de contorno en movimiento : Los mapas de contorno se utilizan en la navegación por la siesta, La tripulación correlaciona las características del terreno vistas fuera de la cabina con las características representadas en el mapa para lograr y mantener la orientación geográfica. Imagen 2 : Una línea de elevación constante representada en una superficie y en un mapa de contorno.\nPantalla de control del tráfico aéreo: Al enrutar y poner en cola el tráfico aéreo, los controladores necesitan recuperar las relaciones espaciales en 3D entre las aeronaves.\nSe han desarrollado y evaluado varios formatos de visualización alternativos que utilizan señales de perspectiva\nImagen 3 : Pantalla de control de tráfico aereo.\nConclusiones # Referencias # Stereokinetic Effect.Neurobs. https://www.neurobs.com/manager/content/docs/psychlab101_experiments/Stereokinetic%20Effect/description.html\nProffitt, D. R., Rock, I., Hecht, H., \u0026amp; Schubert, J. (1992). Stereokinetic effect and its relation to the kinetic depth effect. Journal of Experimental Psychology: Human Perception and Performance, 18(1), 3–21. https://doi.org/10.1037/0096-1523.18.1.3\nG. (2018, 8 noviembre). ¿Qué son las isolíneas, contornos o curvas de nivel? El blog de franz. https://acolita.com/que-son-las-isolineas-contornos-o-curvas-de-nivel/\n"},{"id":1,"href":"/showcase/docs/shortcodes/Visual-Masking/","title":"Visual Masking","section":"Shortcodes","content":" Visual Masking # Workshop Implementar una aplicación web de procesamiento de imagenes que soporte varios kernels y además:\nVisualización de histograma de la imagen Diferentes herramientes de luminosidad Marco teórico # Kernel # Un kernel o mascara es una matriz usada para aplicar algun tipo de efecto como difuminado, detección de bordes , sobre una imagen. Eso se logra realizando una convolución entre el kernel y la imagen. ¿Qué es una convolución?\nEn procesamiento de imagenes, una convolución consiste en multiplicar cada píxel de la imagen por la entrada correspondiente del kernel, luego al sumar todos los resultados, se obtiene el valor del nuevo píxel. A modo de ejemplo, se escogieron los siguientes kernels para mostrar su aplicación:\nSharpening \\[\\begin{bmatrix} 0 \u0026amp; -1 \u0026amp; 0\\\\ -1 \u0026amp; 5 \u0026amp; -1\\\\ 0 \u0026amp; -1 \u0026amp; 0\\\\ \\end{bmatrix}\\] Emboss \\[\\begin{bmatrix} -2 \u0026amp; -1 \u0026amp; 0\\\\ -1 \u0026amp; 1 \u0026amp; 1\\\\ 0 \u0026amp; 1 \u0026amp; 2\\\\ \\end{bmatrix}\\] Blur \\[\\begin{bmatrix} 0.0625 \u0026amp; 0.125 \u0026amp; 0.0625\\\\ 0.125 \u0026amp; 0.25 \u0026amp; 0.125\\\\ 0.0625 \u0026amp; 0.125 \u0026amp; 0.0625\\\\ \\end{bmatrix}\\] Histograma # Un histograma de una imagen consiste en la representación gráfica de la distribución tonal de la imagen, trazando el número de píxeles de cada canal.\nEn el eje horizontal representa las variaciones tonales, mientras que el vertical, representa la cantidad de píxeles en un tono particular.\n¿Cómo interpretar un histograma?\nEl lado izquierdo del eje horizontal representa las áreas oscuras y el derecho representa las áreas iluminadas.\nPor ejemplo, para una imagen oscura, esta tendrá la mayoría de puntos dibujados en el lado izquiero del histograma.\nHerramientas de luminosidad # La luminosidad es la percepción visual de la luminancia de un objeto. En colorimetría, es una predicción de que tan iluminado aparecerá un color para un determinado observador. ¿Qué es la luminancia? Es la médida de intensidad lumínica por unidad de área de la luz viajando en una determinada dirección. Es decir, describe la cantidad de luz que pasa a través, es emitida o reflejada de un área particular.\nExisten varias formas de calcular la luminosidad de un color. A modo de ejemplo, se mostrarán las siguientes 4: Media aritmética \\[I=\\frac{R\u0026#43;G\u0026#43;B}{3}\\] HSV \\[V=max(R,G,B)\\] HSL \\[L=\\frac{max(R,G,B)\u0026#43;min(R,G,B)}{2}\\] Luma \\[Y=0.2126\\cdot R\u0026#43; 0.7152\\cdot G\u0026#43;0.0722\\cdot B\\] Solución y resultados # Kernel # A continuación se muestra la función principal, la cual es la encargada de calcula el nuevo valor de cada píxel:\nlet applyKernelToPixel = (x, y, kernel, kernelSize) =\u0026gt; { let newR = 0.0; let newG = 0.0; let newB = 0.0; // Go through each kernel entry for (let r = 0; r \u0026lt; kernelSize; r++) { for (let c = 0; c \u0026lt; kernelSize; c++) { // Compute the offset let rowOffset = 1 - r; let colOffset = 1 - c; let imageRow = x - rowOffset; let imageCol = y - colOffset; let currentPixel = originalImg.get(imageRow, imageCol); // Compute new value for each channel newR += p.red(currentPixel) * kernel[r][c]; newG += p.green(currentPixel) * kernel[r][c]; newB += p.blue(currentPixel) * kernel[r][c]; } } // In case the new value is greater than 255 newR = p.constrain(newR, 0, 255); newG = p.constrain(newG, 0, 255); newB = p.constrain(newB, 0, 255); return p.color(newR, newG, newB); }; Histograma # A continuación se muestra la función principal, la cual es la encargada de contar la cantidad de píxeles en cada valor de un determinado canal:\nlet countPixels = () =\u0026gt; { // Go through each pixel for (let x = 0; x \u0026lt; img.width; x++) { for (let y = 0; y \u0026lt; img.height; y++) { let pixel = img.get(x, y); // Add 1 to the current tonal value let value = currentColor === \u0026#34;red\u0026#34; ? p.red(pixel) : currentColor === \u0026#34;green\u0026#34; ? p.green(pixel) : p.blue(pixel); pixels[value] += 1; } } }; Herramientas de luminosidad # A continuación, se muestra la implementación de las 4 maneras de calcular la luminosidad expuestas anteriormente, junto con la función encargada de aplicar ese cálculo a cada pixel de la imagen:\nlet lightnessModes = { mean: (color) =\u0026gt; { return (p.red(color) + p.green(color) + p.blue(color)) / 3; }, hsv: (color) =\u0026gt; { return Math.max((p.red(color), p.green(color), p.blue(color))); }, hsl: (color) =\u0026gt; { let max = Math.max((p.red(color), p.green(color), p.blue(color))); let min = Math.min((p.red(color), p.green(color), p.blue(color))); return (max + min) / 2; }, luma: (color) =\u0026gt; { return ( 0.2126 * p.red(color) + 0.7152 * p.green(color) + 0.0722 * p.blue(color) ); }, }; let applyLightness = (mode) =\u0026gt; { // Extract the current function let lightness = lightnessModes[mode]; // Go through each pixel for (let i = 0; i \u0026lt; originalImg.width; i++) { for (let j = 0; j \u0026lt; originalImg.height; j++) { let newPixel = lightness(originalImg.get(i, j)); currentImg.set(i, j, p.color(newPixel)); } } }; Conclusiones # La aplicación de una convolución usando un kernel a una imagen se vería en extremo beneficiada por la paralelización de dicha aplicación Se deben considerar todas las formas de calcular la luminosidad de una imagen a la hora de pasar la imagen a escala de grises "}]